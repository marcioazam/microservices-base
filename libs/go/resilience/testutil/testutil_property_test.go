package testutil

import (
	"testing"

	"github.com/auth-platform/libs/go/resilience"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
)

// **Feature: resilience-lib-extraction, Property 10: Generated Configs Pass Validation**
// **Validates: Requirements 4.1, 4.2**
// *For any* configuration generated by the test generators, calling Validate() SHALL return nil (no error).
func TestGeneratedConfigsPassValidation(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	properties := gopter.NewProperties(parameters)

	properties.Property("generated circuit breaker configs are valid", prop.ForAll(
		func(cfg resilience.CircuitBreakerConfig) bool {
			return cfg.Validate() == nil
		},
		GenCircuitBreakerConfig(),
	))

	properties.Property("generated retry configs are valid", prop.ForAll(
		func(cfg resilience.RetryConfig) bool {
			return cfg.Validate() == nil
		},
		GenRetryConfig(),
	))

	properties.Property("generated timeout configs are valid", prop.ForAll(
		func(cfg resilience.TimeoutConfig) bool {
			return cfg.Validate() == nil
		},
		GenTimeoutConfig(),
	))

	properties.Property("generated rate limit configs are valid", prop.ForAll(
		func(cfg resilience.RateLimitConfig) bool {
			return cfg.Validate() == nil
		},
		GenRateLimitConfig(),
	))

	properties.Property("generated bulkhead configs are valid", prop.ForAll(
		func(cfg resilience.BulkheadConfig) bool {
			return cfg.Validate() == nil
		},
		GenBulkheadConfig(),
	))

	properties.Property("generated resilience policies are valid", prop.ForAll(
		func(policy resilience.ResiliencePolicy) bool {
			return policy.Validate() == nil
		},
		GenResiliencePolicy(),
	))

	properties.TestingRun(t)
}

// **Feature: resilience-lib-extraction, Property 15: Mock Event Emitter Recording**
// **Validates: Requirements 4.3**
// *For any* sequence of events emitted to a MockEventEmitter, GetEvents() SHALL return all emitted events in order.
func TestMockEventEmitterRecording(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	properties := gopter.NewProperties(parameters)

	properties.Property("emitter records all events in order", prop.ForAll(
		func(n int) bool {
			emitter := NewMockEventEmitter()

			// Emit n events
			for i := 0; i < n; i++ {
				event := resilience.NewEvent(resilience.EventCircuitStateChange, "test-service").
					WithMetadata("index", i)
				emitter.Emit(*event)
			}

			events := emitter.GetEvents()
			if len(events) != n {
				return false
			}

			// Verify order
			for i, e := range events {
				if e.Metadata["index"] != i {
					return false
				}
			}
			return true
		},
		gen.IntRange(0, 50),
	))

	properties.Property("emitter records all audit events", prop.ForAll(
		func(n int) bool {
			emitter := NewMockEventEmitter()

			// Emit n audit events
			for i := 0; i < n; i++ {
				event := resilience.NewAuditEvent("action", "resource", "success").
					WithMetadata("index", i)
				emitter.EmitAudit(*event)
			}

			events := emitter.GetAuditEvents()
			return len(events) == n
		},
		gen.IntRange(0, 50),
	))

	properties.Property("clear removes all events", prop.ForAll(
		func(n int) bool {
			emitter := NewMockEventEmitter()

			// Emit events
			for i := 0; i < n; i++ {
				event := resilience.NewEvent(resilience.EventCircuitStateChange, "test")
				emitter.Emit(*event)
				audit := resilience.NewAuditEvent("action", "resource", "success")
				emitter.EmitAudit(*audit)
			}

			emitter.Clear()

			return emitter.EventCount() == 0 && emitter.AuditEventCount() == 0
		},
		gen.IntRange(0, 20),
	))

	properties.TestingRun(t)
}
