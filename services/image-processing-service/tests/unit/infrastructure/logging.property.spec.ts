import * as fc from 'fast-check';
import { PlatformLoggingClient, LogLevel, LogContext } from '../../../src/infrastructure/logging/client';

/**
 * Feature: image-processing-modernization-2025
 * Property 1: Log Entries Contain Required Context
 * 
 * For any log entry generated by the service, the entry SHALL contain both
 * a correlation ID (requestId) and trace context (traceId, spanId) when available.
 * 
 * Validates: Requirements 1.2, 1.4
 */
describe('Property 1: Log Entries Contain Required Context', () => {
  let capturedLogs: string[] = [];
  const originalConsoleInfo = console.info;

  beforeEach(() => {
    capturedLogs = [];
    console.info = (msg: string) => { capturedLogs.push(msg); };
  });

  afterEach(() => {
    console.info = originalConsoleInfo;
  });

  it('should include requestId as correlationId when provided', async () => {
    await fc.assert(
      fc.property(
        fc.uuid(),
        fc.string({ minLength: 1, maxLength: 100 }),
        (requestId, message) => {
          const client = new PlatformLoggingClient('');
          client.info(message, { requestId });

          expect(capturedLogs.length).toBeGreaterThan(0);
          const entry = JSON.parse(capturedLogs[capturedLogs.length - 1]);
          
          expect(entry.requestId).toBe(requestId);
          expect(entry.correlationId).toBe(requestId);
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should include traceId and spanId when provided', async () => {
    await fc.assert(
      fc.property(
        fc.hexaString({ minLength: 32, maxLength: 32 }),
        fc.hexaString({ minLength: 16, maxLength: 16 }),
        fc.string({ minLength: 1, maxLength: 100 }),
        (traceId, spanId, message) => {
          const client = new PlatformLoggingClient('');
          client.info(message, { traceId, spanId });

          expect(capturedLogs.length).toBeGreaterThan(0);
          const entry = JSON.parse(capturedLogs[capturedLogs.length - 1]);
          
          expect(entry.traceId).toBe(traceId);
          expect(entry.spanId).toBe(spanId);
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should include all context fields when all are provided', async () => {
    await fc.assert(
      fc.property(
        fc.uuid(),
        fc.hexaString({ minLength: 32, maxLength: 32 }),
        fc.hexaString({ minLength: 16, maxLength: 16 }),
        fc.string({ minLength: 1, maxLength: 100 }),
        (requestId, traceId, spanId, message) => {
          const client = new PlatformLoggingClient('');
          client.info(message, { requestId, traceId, spanId });

          expect(capturedLogs.length).toBeGreaterThan(0);
          const entry = JSON.parse(capturedLogs[capturedLogs.length - 1]);
          
          expect(entry.requestId).toBe(requestId);
          expect(entry.correlationId).toBe(requestId);
          expect(entry.traceId).toBe(traceId);
          expect(entry.spanId).toBe(spanId);
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should preserve context in child loggers', async () => {
    await fc.assert(
      fc.property(
        fc.uuid(),
        fc.hexaString({ minLength: 32, maxLength: 32 }),
        fc.string({ minLength: 1, maxLength: 100 }),
        (requestId, traceId, message) => {
          const parent = new PlatformLoggingClient('');
          const child = parent.child({ requestId, traceId });
          child.info(message);

          expect(capturedLogs.length).toBeGreaterThan(0);
          const entry = JSON.parse(capturedLogs[capturedLogs.length - 1]);
          
          expect(entry.requestId).toBe(requestId);
          expect(entry.traceId).toBe(traceId);
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should include timestamp in ISO 8601 format', async () => {
    await fc.assert(
      fc.property(
        fc.string({ minLength: 1, maxLength: 100 }),
        (message) => {
          const before = new Date().toISOString();
          const client = new PlatformLoggingClient('');
          client.info(message);
          const after = new Date().toISOString();

          expect(capturedLogs.length).toBeGreaterThan(0);
          const entry = JSON.parse(capturedLogs[capturedLogs.length - 1]);
          
          expect(entry.timestamp).toBeDefined();
          expect(new Date(entry.timestamp).toISOString()).toBe(entry.timestamp);
          expect(entry.timestamp >= before).toBe(true);
          expect(entry.timestamp <= after).toBe(true);
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should include serviceId in all log entries', async () => {
    await fc.assert(
      fc.property(
        fc.constantFrom(LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR),
        fc.string({ minLength: 1, maxLength: 100 }),
        (level, message) => {
          // Capture all console methods
          const logs: string[] = [];
          const origDebug = console.debug;
          const origInfo = console.info;
          const origWarn = console.warn;
          const origError = console.error;
          
          console.debug = (msg: string) => logs.push(msg);
          console.info = (msg: string) => logs.push(msg);
          console.warn = (msg: string) => logs.push(msg);
          console.error = (msg: string) => logs.push(msg);

          try {
            const client = new PlatformLoggingClient('');
            client.log(level, message);

            expect(logs.length).toBeGreaterThan(0);
            const entry = JSON.parse(logs[logs.length - 1]);
            expect(entry.serviceId).toBe('image-processing-service');
          } finally {
            console.debug = origDebug;
            console.info = origInfo;
            console.warn = origWarn;
            console.error = origError;
          }
        }
      ),
      { numRuns: 100 }
    );
  });
});
